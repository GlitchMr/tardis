#!/opt/perl/bin/perl -w
use strict;
use v5.010;

# The program forms a simple eval-compile-serialize loop. Here are the kinds
# of programs recognized.
#
# ;
# 42;
# my $a;
# my $a = 42;
# my $a = $a;
# my $a; my $b;
# my $a = my $b = 42;
# my $a; my $a; my $a;
# my $a := 42; my $b = $a;
# my $a; my $b := $a; $a = 42;

my $p6program;

{
    use Regexp::Grammars;

    $p6program = qr{
        ^ <[Statement]> ** (;) $

        <objrule: AST::Statement>
            <Expression> | (?:)

        <objrule: AST::Expression>
            <Variable> | <Literal> | <Declaration> | <Assignment> | <Binding>

        <objrule: AST::Lvalue>
            <Variable> | <Declaration>

        <objrule: AST::Variable>
            \$\w+

        <objrule: AST::Literal>
            \d+

        <objrule: AST::Declaration>
            my <Variable>

        <objrule: AST::Assignment>
            <Lvalue> = <Expression>

        <objrule: AST::Binding>
            <Lvalue> := <Expression>
    }xms;
}

my %d;
sub findvars {
    my ($node) = @_;
    given (ref($node)) {
        when ('AST::Statement') {
            if (exists $node->{Expression}) {
                findvars($node->{Expression});
            }
        }
        when ('AST::Expression') {
            for my $subrule (<Variable Declaration Assignment Binding>) {
                if (exists $node->{$subrule}) {
                    findvars($node->{$subrule});
                }
            }
        }
        when ('AST::Lvalue') {
            for my $subrule (<Variable Declaration>) {
                if (exists $node->{$subrule}) {
                    findvars($node->{$subrule});
                }
            }
        }
        when ('AST::Variable') {
            if (!exists $d{ $node->{''} }) {
                die 'Invalid. ', $node->{''}, " not declared before use.\n";
            }
        }
        when ('AST::Declaration') {
            ++$d{ $node->{Variable}{''} };
        }
        when ('AST::Assignment') {
            findvars($node->{Lvalue});
            findvars($node->{Expression});
        }
        when ('AST::Binding') {
            findvars($node->{Lvalue});
            findvars($node->{Expression});
        }
        default {
            die "Don't know what to do with an ", ref($node);
        }
    }
}

my $c = 0;
sub unique_register {
    return '$' . $c++;
}

my @s;
sub sicify {
    my ($node) = @_;
    given (ref($node)) {
        when ('AST::Statement') {
            if (exists $node->{Expression}) {
                return sicify($node->{Expression});
            }
        }
        when ('AST::Expression') {
            for my $subrule (<Variable Literal Declaration Assignment Binding>) {
                if (exists $node->{$subrule}) {
                    return sicify($node->{$subrule});
                }
            }
        }
        when ('AST::Lvalue') {
            for my $subrule (<Variable Declaration>) {
                if (exists $node->{$subrule}) {
                    return sicify($node->{$subrule});
                }
            }
        }
        when ('AST::Variable') {
            my $register = unique_register;
            my $variable = "'" . $node->{''} . "'";
            push @s, "$register = fetch $variable";
            return ($register, $variable);
        }
        when ('AST::Literal') {
            my $register = unique_register;
            my $literal = $node->{''};
            push @s, "$register = $literal";
            return ($register, $literal);
        }
        when ('AST::Declaration') {
            my ($register, $variable) = sicify($node->{Variable});
            return ($register, $variable);
        }
        when ('AST::Assignment') {
            my ($register) = sicify($node->{Expression});
            my (undef, $variable) = sicify($node->{Lvalue});
            push @s, "store $variable, $register";
            return ($register, $variable);
        }
        when ('AST::Binding') {
            my ($register, $rightvar) = sicify($node->{Expression});
            my (undef, $leftvar) = sicify($node->{Lvalue});
            push @s, "bind $leftvar, $rightvar";
            return ($register, $leftvar);
        }
        default {
            die "Don't know what to do with an ", ref($node);
        }
    }
    return;
}

sub declutter {
    my ($instructions) = @_;
    my $i = 0;
    while ($i < @$instructions) {
        my $line = $instructions->[$i];
        if ($line =~ / ^ (\$ \d+) \s = /x) {
            my $varname = $1;
            my $usages_later = 0;
            for my $j ($i+1..@$instructions-1) {
                ++$usages_later if index($instructions->[$j], $varname) >= 0;
            }
            if (!$usages_later) {
                splice(@$instructions, $i, 1);
                --$i;
            }
        }
        ++$i;
    }
}

sub renumber {
    my ($instructions) = @_;
    my $next_number = 0;
    my %mapping;
    for my $line (@$instructions) {
        while ($line =~ / (\$ \d+) /xg) {
            my $varname = $1;
            if (!exists $mapping{$varname}) {
                # '&' rather than '$' to avoid infinite substitution loops
                $mapping{$varname} = '&' . $next_number++;
            }
            $line =~ s[\Q$varname\E][$mapping{$varname}]ge;
        }
        $line =~ s[\&][\$]g;
    }
}

while (<>) {
    unless (/$p6program/) {
        warn "Doesn't parse.\n";
        next;
    }

    %d = ();
    eval {
        for my $statement (@{ $/{Statement} }) {
            findvars($statement);
        }
    };
    if ($@) {
        warn $@;
        next;
    }
    $c = 0;
    @s = ();
    for my $statement (@{ $/{Statement} }) {
        sicify($statement);
    }
    declutter(\@s);
    renumber(\@s);
    for my $s (@s) {
        say "\x09", $s;
    }
}
